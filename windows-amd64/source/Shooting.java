/* autogenerated by Processing revision 1286 on 2023-01-08 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.ArrayList;
import java.util.List;
import java.util.Iterator;
import ddf.minim.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Shooting extends PApplet {






boolean left, right, up, down, shift, z;

int scene_num = 0;
int stageCode = 0;

Stage stage;
Title title;
GameOver gameover;
Clear clear;

int totalScore = 0;

Minim minim;

 public void setup(){
  colorMode(HSB, 360, 100, 100, 100);
  /* size commented out by preprocessor */;
  /* smooth commented out by preprocessor */;
  textSize(mojiSize);
  title = new Title();
  gameover = new GameOver();
  clear = new Clear();
  minim = new Minim(this);
}

 public void draw(){
  switch(scene_num){
    case STATUS_GAME_TITLE:
      title.updateMe();
      break;
    case STATUS_GAME_PLAYING:
      stage.updateMe();
      break;
    case STATUS_GAME_GAMEOVER:
      if(getStage().bgm_Stage.isPlaying()){getStage().bgm_Stage.pause();}
      gameover.updateMe();
      break;
    case STATUS_GAME_CLEAR:
      clear.updateMe();
      break;
  }
}

 public void scene_Title(){
}

 public void scene_GameOver(){
  background(0);
  textAlign(CENTER);
  textSize(64);
  text("Gameover", width / 2, height / 2 - 64);
  textSize(32);
  text("Press Z", width / 2, height / 2 - 32);
}

 public void gameReset(){
  totalScore = 0;
}

 public void scene_Game(){
  background(0);
  getStage().updateMe();
  
  stage_Seigyo();
}

 public void stage_Seigyo(){
  
}

 public void scene_Clear(){
  background(0);
  textAlign(CENTER);
  textSize(64);
  text("Stage Clear", width / 2, height / 2 - 64);
  textSize(32);
  text("Press Z", width / 2, height / 2 + 64);
}

 public Stage getStage(){
  return stage;
}

 public void keyPressed(){
  switch(scene_num){
    case STATUS_GAME_TITLE:
      title.keyInsert();
    break;
    case 1:
    if(keyCode == LEFT)left = true;
    if(keyCode == RIGHT) right = true;
    if(keyCode == UP) up = true;
    if(keyCode == DOWN) down = true;
    if(keyCode == SHIFT) shift = true;
    if(keyCode == 'Z') z = true;
    break;
    case 2:
      gameover.keyInsert();
    break;
    case 3:
      clear.keyInsert();
    break;
  }
  
}

 public void keyReleased(){
  if(keyCode == LEFT) left = false;
  if(keyCode == RIGHT) right = false;
  if(keyCode == UP) up = false;
  if(keyCode == DOWN) down = false;
  if(keyCode == SHIFT) shift = false;
  if(keyCode == 'Z') z = false;
}
class Clear{
  
  Clear(){
    
  }
  
   public void updateMe(){
    drawMe();
  }
  
   public void drawMe(){
    background(0);
  }
  
   public void keyInsert(){
    if(keyCode == 'Z'){
      gameReset();
      scene_num = STATUS_GAME_TITLE;
    }
  }
}
class Item{
  PVector pos;
  PVector vel;
  float speed;
  int type;
  int col;
  float atari;
  float suiyose_hani;  //吸い寄せ範囲に入ると自動回収なる
  boolean isAutoKaishu;  //回収ラインより上にいくと自動で回収されるようになる
  boolean isActive = false;
  
  Item(float _x, float _y,  int _type){
    pos = new PVector(_x, _y);
    speed = 1.25f;
    vel = new PVector(0, speed);
    type = _type;
    atari = 10;
    suiyose_hani = 60;
    isAutoKaishu = false;
    switch(type){
      case TYPE_ITEM_POINT:
        col = color(240, 50, 100, 50);
      break;
      case TYPE_ITEM_LIFE:
        col = color(330, 50, 100, 50);
      break;
      case TYPE_ITEM_BOMB:
        col = color(150, 50, 100, 50);
      break;
    }
    isActive = true;
  }
  
   public void drawMe(){
    noStroke();
    fill(col);
    quad(pos.x + cos(radians(0)) * atari, pos.y + sin(radians(0)) * atari,
         pos.x + cos(radians(90)) * atari, pos.y + sin(radians(90)) * atari,
         pos.x + cos(radians(180)) * atari, pos.y + sin(radians(180)) * atari,
         pos.x + cos(radians(270)) * atari, pos.y + sin(radians(270)) * atari);
  }
  
   public void updateMe(){
    pos.add(vel);
    //corrisionToItem(this);
    if(isOutOfScreen()){isActive = false;}
    drawMe();
  }
  
   public void attract(Jiki jiki){
    float angle = atan2(jiki.pos.y - this.pos.y, jiki.pos.x - this.pos.x);
    vel.x = 10 * cos(angle);
    vel.y = 10 * sin(angle);
  }

   public boolean corrisionToJiki(Jiki jiki){
    float d = dist(jiki.pos.x, jiki.pos.y, pos.x, pos.y);
    boolean ans = false;
    if(d <= jiki.atari + atari){
      ans = true;
    }
    return ans;
  }
  
   public boolean suiyoseToJiki(Jiki jiki){
    float d = dist(jiki.pos.x, jiki.pos.y, pos.x, pos.y);
    boolean ans = false;
    if(d <= jiki.atari + suiyose_hani){
      ans = true;
    }
    return ans;
  }
  
   public boolean isOutOfScreen(){
    if(pos.x > width + atari || pos.x < 0 - atari || pos.y > height + atari || pos.y < 0 - atari){
      return true;
    }
    return false;
  }
}
class Jiki{
  //String state;
  PVector pos;
  int HP;
  int Bomb;
  float speed;
  int size;
  float atari;
  int col;
  int count_jiki;
  float graze;
  int muteki_frame;
  List<jikiDan> shots;
  JikiWeapon weapon;
  int grazeCount;
  AudioPlayer SE_Graze;
  AudioPlayer SE_Gekitsui;
  
  Jiki(){
    //state = "active";
    pos = new PVector(width / 2, height / 2);
    HP = 10;
    Bomb = 3;
    speed = 2.5f;
    size = 15;
    col = color(180, 100, 100);
    count_jiki = 0;
    atari = size / 4;
    graze = size;
    weapon = JikiWeapon.none;
    grazeCount = 0;
    shots = new ArrayList<jikiDan>();
    SE_Graze = minim.loadFile("魔王魂 効果音 システム26.mp3");
    SE_Gekitsui = minim.loadFile("魔王魂 効果音 システム09.mp3");
  }
  
   public void HPDown(){  //HPを減らす処理をするときはこれをやろうね
    SE_Gekitsui.play(0);
    HP--;
    muteki(20);
  }
  
   public void muteki(int frame){  //指定フレームだけ時期を無敵にする
    muteki_frame = count_jiki + frame;
  }
  
   public void drawMe(){
    noStroke();
    if(shift == true){  //低速ときに判定見えるようにするやつ
      fill(col);
      ellipse(pos.x, pos.y, atari * 2, atari * 2);
      fill(col, 50);
    }else{
      fill(col);
    }
    triangle(pos.x + cos(radians(30)) * size, pos.y + sin(radians(30)) * size,
    pos.x + cos(radians(150)) * size, pos.y + sin(radians(150)) * size,
    pos.x + cos(radians(270)) * size, pos.y + sin(radians(270)) * size);
  }
  
   public void updateMe(){
    jiki_Move();
    if(z == true){
      jiki_Shot();
    }
    updateBullets();
    
    count_jiki++;
    drawMe();
  }
  
  //自機操作用
   public void jiki_Move(){
    float movespeed = speed;
    
    if(shift == true) movespeed *= 0.5f;
    
    if((up == true || down == true) && (left == true || right == true)){
      movespeed *= 0.71f;
    }
    
    if(right == true){
      pos.x += movespeed;
      if(pos.x > (width / 2 + Play_Haba / 2) - size) pos.x = (width / 2 + Play_Haba / 2) - size;
    }
    if(left == true){
      pos.x -= movespeed;
      if(pos.x < (width / 2 - Play_Haba / 2) + size) pos.x = (width / 2 - Play_Haba / 2) + size;
    }
    if(up == true){
      pos.y -= movespeed;
      if(pos.y < size) pos.y = size;
    }
    if(down == true){
      pos.y += movespeed;
      if(pos.y > height - size) pos.y = height - size;
    }
  }
  
   public void jiki_Shot(){
  
  }
  
   public void shootDown(){
    
  }
  
  //自機ショット更新
   public void updateBullets(){
    Iterator<jikiDan> it = shots.iterator();
    while(it.hasNext()){
      jikiDan d = it.next();
      if(d.isActive){
        d.updateMe();
      }else{
        it.remove();
      }
    }
  }
  
   public void executeGraze(tekiDan d){
    SE_Graze.play(0);
    Stage s = getStage();
    for(int i = 0; i < 3; i++){  //グレイズエフェクト：対レーザーだと変なところにエフェクト出るからなんかしたほうがいいかもしれん。
      PVector v = PVector.mult(PVector.sub(d.pos, pos).normalize(), size);
      popParticle p = new popParticle(pos.x + v.x, pos.y + v.y, 1, random(TWO_PI), d.size / 2, d.col);
      s.particles.add(p);
    }
    grazeCount++;
  }
  
  //無敵時間さん！？かどうか
   public boolean isInvincible(){
    if(muteki_frame > count_jiki){
      return true;
    }else{
      return false;
    }
  }
}

class jikiDan extends Dan {
  int HP;  //貫通力、この回数だけ敵に当たれる、貫通ショットを作りたければここ増やせばいい
  int damage;  //敵に与えるダメージ
  Enemy targetEnemy = null;

  jikiDan(float _x, float _y, float _speed, float _angle, int _size, int _col, int _damage) {
    super(_x, _y, _speed, _angle, _size, _col);
    HP = 1;
    atari = _size;
    damage = _damage;
  }

   public void drawMe() {
    fill(col);
    noStroke();
    ellipse(pos.x, pos.y, atari, atari);
  }

   public void updateMe() {
    super.updateMe();
    if(HP <= 0){isActive = false;}
    drawMe();
  }
  
   public boolean isHitEnemy(Enemy e){
    float d = dist(e.pos.x, e.pos.y, this.pos.x, this.pos.y);
    if(d < e.atari + this.atari){
      return true;
    }else{
      return false;
    }
  }
}
class standard extends Jiki{
  standard(){
    super();
    col = color(180, 100, 100);
  }
  
   public void jiki_Shot(){
    if(count_jiki % 5 == 0){
      if(shift){
        for(int i = -10; i <= 10; i += 5){
          standardShot s = new standardShot(pos.x, pos.y + 4, radians(i - 90));
          shots.add(s);
        }
      }else{
        for(int i = -20; i <= 20; i += 10){
          standardShot s = new standardShot(pos.x, pos.y + 4, radians(i - 90));
          shots.add(s);
        }
      }
    }
  }
}

class standardShot extends jikiDan{
  standardShot(float _x, float _y, float _angle){
    super(_x, _y, 7, _angle, 8, color(180, 100, 100, 50), 1);
  }
  
   public void drawMe(){
    pushMatrix();
      translate(pos.x, pos.y);
      rotate(vel.heading());
      noStroke();
      fill(col);
      ellipse(0, 0, size, atari);
    popMatrix();
  }
}

class lay extends Jiki{
  lay(){
    super();
    col = color(155, 100, 100);
  }
  
   public void jiki_Shot(){
    if(count_jiki % 12 == 0){
      for(int i = -32; i <= 32; i += 16){
        layShot s1 = new layShot(pos.x + i, pos.y + 4, radians(-90));
        shots.add(s1);
      }
    }
  }
}

class layShot extends jikiDan{
  PVector bpos;
  layShot(float _x, float _y, float _angle){
    super(_x, _y, 12, _angle, 8, color(155, 100, 100, 50), 4);
    accel = createVectorFromLengthAngle(0.5f, _angle);
    bpos = pos;
    HP = 10;
  }
  
   public void drawMe(){
    //fill(360);
    //ellipse(pos.x, pos.y, size, size);
    HenyoriTail henyo = new HenyoriTail(pos.x, pos.y, bpos.x, bpos.y, size, col);
    henyo.lifetime = 5;
    Stage s = getStage();
    s.particles.add(henyo);
    bpos = new PVector(pos.x, pos.y);
  }
}

class homing extends Jiki{
  homing(){
    super();
    col = color(100, 100, 100);
  }
  
   public void jiki_Shot(){
    if(count_jiki % 10 == 0){
      homingShot s1 = new homingShot(pos.x - 8, pos.y - 4);
      homingShot s2 = new homingShot(pos.x + 8, pos.y - 4);
      shots.add(s1);
      shots.add(s2);
    }
    if(count_jiki % 5 == 0){
      for(int i = -10; i <= 10; i += 10){
        standardShot s = new standardShot(pos.x + i, pos.y - 4, radians(-90));
        s.damage = 1;
        s.col = color(75, 100, 100, 25);
        shots.add(s);
      }
    }
  }
}

class homingShot extends jikiDan{
  Enemy targetEnemy;
  homingShot(float _x, float _y){
    super(_x, _y, 5, radians(-90), 16, color(140, 100, 100, 50), 1);
    targetEnemy = getTarget();
  }
  
  //追跡対象を設定（弾の追跡対象は途中で変わらない）
   public Enemy getTarget(){
    Enemy nearByEnemy = null;
    float kyori = 1000;
    Stage s = getStage();
    if(s != null){
      List es = s.getEnemyArray();
      Iterator<Enemy> it = es.iterator();
      while(it.hasNext()){
        Enemy e = it.next();
        if(e.status == STATUS_ENEMY_ACTIVE){
          float kyoriNow = dist(pos.x, pos.y, e.pos.x, e.pos.y);
          if (kyoriNow <= kyori) {
            kyori = kyoriNow;
            nearByEnemy = e;
          }
        }
      }
    }
    return nearByEnemy;
  }
  
   public void updateMe(){
    super.updateMe();
    homing();
  }

   public void homing() {  //最初にホーミング弾の対象を決めて、上書きされないようにしたい
    if (targetEnemy != null && targetEnemy.status == STATUS_ENEMY_ACTIVE) {
      PVector vecToEnem = PVector.sub(targetEnemy.pos, pos).normalize();
      this.vel = vecToEnem.mult(5);
    }
  }
}

class fire extends Jiki{
  fire(){
    super();
    col = color(330, 100, 100);
  }
  
   public void jiki_Shot(){
    fireShot s = new fireShot(pos.x, pos.y - 16);
    shots.add(s);
  }
}

class fireShot extends jikiDan{
  fireShot(float x, float y){
    super(x, y, 10 + random(-3, 3), radians(random(-15, 15) - 90), 50, color(330, 100, 100, 30), 7);
  }
  
   public void drawMe(){
    fill(col);
    noStroke();
    ellipse(pos.x, pos.y, atari, atari);
    atari -= 1.5f;
    if(atari <= 0){
      isActive = false;
    }
  }
}
class Laser extends tekiDan{  //れーざー:線当たり判定にする(太さは、並べて作るとかでできるか？)
  PVector base;  //ケツの位置
  PVector def;
  float len;  //長さ
  //sizeを太さとして扱う。

  Laser(float _x, float _y, float _speed, float _angle, float _wid, float _len, int _col) {
    //state = "active";
    super(_x,  _y, _speed, _angle, _wid, _col);
    base = new PVector(pos.x, pos.y);
    def = new PVector(pos.x, pos.y);  //posを直接参照してしまうとposの値が描き変わったときにdefの値も書き変わってしまうらしいです。
    atari = size / 2;
    len = _len;
    col = _col;
    icol = color(0, 0, 100);
  }

   public void drawMe() {
    strokeWeight(size);
    stroke(col);
    line(base.x, base.y, pos.x, pos.y);
    strokeWeight(atari);
    stroke(icol);
    line(base.x, base.y, pos.x, pos.y);
    noStroke();
    fill(col);
    ellipse(base.x, base.y, size * 2, size * 2);
    /*fill(col);
     quad(axD, ayD, bxD, byD, cxD, cyD, dxD, dyD);
     fill(icol);
     quad(ax, ay, bx, by, cx, cy, dx, dy);*/
    noStroke();
  }

   public void updateMe() {
    super.updateMe();
    
    base = PVector.sub(pos, PVector.mult(vel.normalize(null), len));  //normalize 引数nullにしないとvelが上書きされる。
    
    
    if(vel.x > 0){
      if(base.x < def.x){
        base.x = def.x;
      }
    }else if(vel.x < 0){
      if(base.x > def.x){
        base.x = def.x;
      }
    }
    if(vel.y > 0){
      if(base.y < def.y){
        base.y = def.y;
      }
    }else if(vel.y < 0){
      if(base.y > def.y){
        base.y = def.y;
      }
    }
    
    
  }
  
   public boolean isOutOfScreen(){
    if (base.x > width || base.x < 0 || base.y > height || base.y < 0) {
      return true;
    }
    return false;
  }
  
  //直線と円の当たり判定をatari * 2（左右分）本束ねて判定
  //
   public boolean isHitJiki(Jiki jiki){
    if(lineCollisionToJiki(jiki, jiki.atari, pos.x, pos.y, base.x, base.y)){return true;}
    
    for(int i = 1; i <= atari; i++){
      PVector posMinusI = new PVector(pos.x + i * cos(vel.heading()), pos.y + i * sin(vel.heading()));
      PVector posPlusI = new PVector(pos.x + i * cos(vel.heading() + PI), pos.y + i * sin(vel.heading() + PI));
      PVector baseMinusI = new PVector(base.x + i * cos(vel.heading()), base.y + i * sin(vel.heading()));
      PVector basePlusI = new PVector(base.x + i * cos(vel.heading() + PI), base.y + i * sin(vel.heading() + PI));
      
      if(lineCollisionToJiki(jiki, jiki.atari, posMinusI.x, posMinusI.y, baseMinusI.x, baseMinusI.y)){return true;}
      if(lineCollisionToJiki(jiki, jiki.atari, posPlusI.x, posPlusI.y, basePlusI.x, basePlusI.y)){return true;}
    }
    
    return false;
  }
  
   public boolean isGrazeJiki(Jiki jiki){
    if(lineCollisionToJiki(jiki, jiki.atari, pos.x, pos.y, base.x, base.y)){return true;}
    
    for(int i = 1; i <= atari / 2; i++){
      PVector posMinusI = new PVector(pos.x + i * cos(vel.heading()), pos.y + i * sin(vel.heading()));
      PVector posPlusI = new PVector(pos.x + i * cos(vel.heading() + PI), pos.y + i * sin(vel.heading() + PI));
      PVector baseMinusI = new PVector(base.x + i * cos(vel.heading()), base.y + i * sin(vel.heading()));
      PVector basePlusI = new PVector(base.x + i * cos(vel.heading() + PI), base.y + i * sin(vel.heading() + PI));
      
      if(lineCollisionToJiki(jiki, jiki.graze, posMinusI.x, posMinusI.y, baseMinusI.x, baseMinusI.y)){return true;}
      if(lineCollisionToJiki(jiki, jiki.graze, posPlusI.x, posPlusI.y, basePlusI.x, basePlusI.y)){return true;}
    }
    
    return false;
  }
  
   public boolean lineCollisionToJiki(Jiki jiki, float _atari, float headX, float headY, float rootX, float rootY){
    PVector head = new PVector(headX, headY);
    PVector root = new PVector(rootX, rootY);
    
    PVector lineVec = PVector.sub(root, head); //線分のベクトル
    PVector headToAtari = PVector.sub(jiki.pos, head);  //自機の中心から線分の頭まで
    PVector rootToAtari = PVector.sub(jiki.pos, root);  //自機の中心から線分のケツまで
    
    PVector lineNorm = lineVec.normalize();
    PVector cross01 = lineNorm.cross(headToAtari);  //線分に向かって中心からおろしたベクター
    
    //内積と円の半径を比較
    if(cross01.mag() < _atari){
      //当たっているかもしれない
      float d1 = lineVec.dot(headToAtari);
      float d2 = lineVec.dot(rootToAtari);
      
      //2つの内積の掛け算の結果が0より小さいなら当たっている？
      if(d1 * d2 <= 0){
        return true;
      }else{
        //このとき、当たり判定の中心は線分上にない。
        //が、範囲が頭かケツにかすっている可能性があるので、それを見る
        if(dist(jiki.pos.x, jiki.pos.y, head.x, head.y) <= _atari || dist(jiki.pos.x, jiki.pos.y, root.x, root.y) <= _atari){
          return true;
        }
      }
    }else{
      //当たってない
      return false;
    }
    return false;
  }
}
class Particle{
  PVector pos;
  PVector vel = new PVector(0, 0);
  float alpha = 255;
  float size = 10;
  int c;
  int count = 0;
  int lifetime;
  boolean isActive = false;
  PertType type;
  
  Particle(float _x, float _y, int _c){
    pos = new PVector(_x, _y);
    vel = new PVector(0, 0);
    c = _c;
    isActive = true;
  }
  
   public void drawMe(){
    fill(c, alpha);
    noStroke();
    ellipse(pos.x, pos.y, size, size);
  }
  
   public void updateMe(){
    pos.add(vel);
    count++;
    if(count > lifetime){
      isActive = false;
    }
    drawMe();
  }
  
}

class HenyoriTail extends Particle{
  PVector pos2;
  PertType type;
  int d_col;
  
  HenyoriTail(float _x1, float _y1, float _x2, float _y2, float _size, int _col){
    super(_x1, _y1, color(0, 0, 100));
    pos2 = new PVector(_x2, _y2);
    size = _size;
    d_col = _col;
  }
  
   public void drawMe(){
    stroke(c, alpha);
    strokeWeight(size);
    line(pos.x, pos.y, pos2.x, pos2.y);
    noStroke();
  }
  
   public void updateMe(){
    float s_plus = (saturation(d_col)) / lifetime;
    float v_plus = (100 - brightness(d_col)) / lifetime;
    if(alpha > 0){
      c = color(hue(d_col), saturation(c) + s_plus, brightness(c) - v_plus);
      alpha -= 255 / lifetime;
    }else{
      isActive = false;
    }
    super.updateMe();
  }
  
}

class popParticle extends Particle{
  float defSize;
  popParticle(float _x, float _y, float speed, float angle, float _size, int _c){
    super(_x, _y, _c);
    vel = createVectorFromLengthAngle(speed, angle);
    size = _size;
    lifetime = 10;
    defSize = size;
  }
  
   public void drawMe(){
    fill(c);
    noStroke();
    drawStar(pos.x, pos.y, size, radians(count * 2));
    size -= defSize / lifetime;
  }
}

class expandCircle extends Particle{
  float maxSize;
  int defC;
  
  expandCircle(float _x, float _y, float _maxSize, int _c){
    super(_x, _y, _c);
    defC = c;
    lifetime = 10;
    maxSize = _maxSize;
  }
  
   public void drawMe(){
    lerpColor(defC, color(hue(defC), saturation(defC), brightness(defC), 0), count / lifetime);
    stroke(c);
    strokeWeight(3);
    noFill();
    float size = maxSize / lifetime * count;
    ellipse(pos.x, pos.y, size, size);
  }
}
abstract class Dan {  //おーい、Enemyよりしたになって見づらいのやが
  PVector pos;
  PVector vel;
  PVector accel;
  float atari;  //判定サイズ
  float size;  //見かけサイズ(グレイズする範囲でもある)
  int col;  //色
  int count_dan = 0;  //生まれてからのカウント
  DanShape shape = DanShape.orb;
  float befx, befy;  //前の位置
  int lifetime;  //削除予定時刻
  boolean isActive = false;  //有効な弾かどうか

  Dan(float _x, float _y, float _speed, float _angle, float _size, int _col) {
    //state = "active";
    pos = new PVector(_x, _y);
    vel = createVectorFromLengthAngle(_speed, _angle);
    accel = new PVector(0, 0);
    size = _size;
    atari = size / 1.5f;
    col = _col;
    isActive = true;
  }

  //おーーばーらいど、加速度と角速度つけられるやつ
  Dan(float _x, float _y, float _speed, float _accel, float _angle, float _rotate, float _size, int _col) {
    //state = "active";
    pos = new PVector(_x, _y);
    vel = createVectorFromLengthAngle(_speed, _angle);
    accel = createVectorFromLengthAngle(_accel, _rotate);
    size = _size;
    atari = size / 1.5f;
    col = _col;
  }

   public void drawMe() {
    
  }

   public void updateMe() {
    vel.add(accel);
    pos.add(vel);

    isOutOfScreen();
    count_dan++;
    if((lifetime > 0 && count_dan > lifetime) || isOutOfScreen() == true){
      isActive = false;
    }
    
    drawMe();
  }
  
  //画面内にあるか（画面外にあるなら削除する）
   public boolean isOutOfScreen(){
    if(pos.x > width + size || pos.x < 0 - size || pos.y > height + size || pos.y < 0 - size){
      return true;
    }
    return false;
  }
}

//敵弾クラス
class tekiDan extends Dan{
  boolean isGrazed = false;
  int icol;  //弾内側の色
  
  tekiDan(float _x, float _y, float _speed, float _angle, float _size, int _col) {
    super(_x,  _y, _speed, _angle, _size, _col);
    icol = color(0, 0, 100);
  }

  //おーーばーらいど、加速度と角速度つけられるやつ
  tekiDan(float _x, float _y, float _speed, float _accel, float _angle, float _rotate, float _size, int _col) {
    super(_x, _y, _speed, _accel, _angle, _rotate, _size, _col);
    icol = color(0, 0, 100);
  }
  
   public void updateMe(){
    super.updateMe();
  }
  
   public boolean isHitJiki(Jiki jiki){
    float d = dist(jiki.pos.x, jiki.pos.y, this.pos.x, this.pos.y);
    if(d <= jiki.atari + this.atari){
      return true;
    }else{
      return false;
    }
  }
  
   public boolean isGrazeJiki(Jiki jiki){
    float d = dist(jiki.pos.x, jiki.pos.y, this.pos.x, this.pos.y);
    if(d <= jiki.graze + this.atari && this.isGrazed == false){
      return true;
    }else{
      return false;
    }
  }
}

class orbDan extends tekiDan{  //敵弾（丸型）
  orbDan(float _x, float _y, float _speed, float _angle, float _size, int _col) {
    super(_x,  _y, _speed, _angle, _size, _col);
  }

  //おーーばーらいど、加速度と角速度つけられるやつ
  orbDan(float _x, float _y, float _speed, float _accel, float _angle, float _rotate, float _size, int _col) {
    super(_x, _y, _speed, _accel, _angle, _rotate, _size, _col);
  }
  
   public void drawMe(){
    fill(col);
    noStroke();
    ellipse(pos.x, pos.y, size, size);
    fill(icol);
    ellipse(pos.x, pos.y, atari, atari);
  }
}

class riceDan extends tekiDan{  //敵弾（楕円形）
  riceDan(float _x, float _y, float _speed, float _angle, float _size, int _col) {
    super(_x,  _y, _speed, _angle, _size, _col);
  }

  //おーーばーらいど、加速度と角速度つけられるやつ
  riceDan(float _x, float _y, float _speed, float _accel, float _angle, float _rotate, float _size, int _col) {
    super(_x, _y, _speed, _accel, _angle, _rotate, _size, _col);
  }
  
   public void drawMe(){
    float angle = vel.heading();
    pushMatrix();
      translate(pos.x, pos.y);
      rotate(angle);
      fill(col);
      noStroke();
      ellipse(0, 0, size * 1.55f, size);
      fill(icol);
      ellipse(0, 0, atari * 1.5f, atari);
    popMatrix();
  }
}

class triDan extends tekiDan{  //敵弾（三角形）
  triDan(float _x, float _y, float _speed, float _angle, float _size, int _col) {
    super(_x,  _y, _speed, _angle, _size, _col);
  }

  //おーーばーらいど、加速度と角速度つけられるやつ
  triDan(float _x, float _y, float _speed, float _accel, float _angle, float _rotate, float _size, int _col) {
    super(_x, _y, _speed, _accel, _angle, _rotate, _size, _col);
  }
  
   public void drawMe(){
    float angle = vel.heading();
    fill(col);
    noStroke();
    triangle(pos.x + cos(angle) * size / 2, pos.y + sin(angle) * size / 2,
      pos.x + cos(angle + radians(120)) * size / 2, pos.y + sin(angle + radians(120)) * size / 2,
      pos.x + cos(angle - radians(120)) * size / 2, pos.y + sin(angle - radians(120)) * size / 2);
    fill(icol);
    triangle(pos.x + cos(angle) * atari / 2, pos.y + sin(angle) * atari / 2,
      pos.x + cos(angle + radians(120)) * atari / 2, pos.y + sin(angle + radians(120)) * atari / 2,
      pos.x + cos(angle - radians(120)) * atari / 2, pos.y + sin(angle - radians(120)) * atari / 2);
  }
}

class starDan extends tekiDan{  //敵弾（星形弾）
  starDan(float _x, float _y, float _speed, float _angle, float _size, int _col) {
    super(_x,  _y, _speed, _angle, _size, _col);
  }

  //おーーばーらいど、加速度と角速度つけられるやつ
  starDan(float _x, float _y, float _speed, float _accel, float _angle, float _rotate, float _size, int _col) {
    super(_x, _y, _speed, _accel, _angle, _rotate, _size, _col);
  }
  
   public void drawMe(){
    fill(col);
    noStroke();
    drawStar(pos.x, pos.y, size, radians(count_dan * 2));
    noFill();
    strokeWeight(0.5f);
    stroke(icol);
    drawStar(pos.x, pos.y, atari, radians(count_dan * 2));
    fill(icol);
    noStroke();
    ellipse(pos.x, pos.y, atari, atari);
  }
}

class growDan extends tekiDan{  //光弾（見づらいすぎ、キレそう）
  int step = 6;  //光のぼかし鮮明さ
  
  growDan(float _x, float _y, float _speed, float _angle, float _size, int _col) {
    super(_x,  _y, _speed, _angle, _size, _col);
  }

  //おーーばーらいど、加速度と角速度つけられるやつ
  growDan(float _x, float _y, float _speed, float _accel, float _angle, float _rotate, float _size, int _col) {
    super(_x, _y, _speed, _accel, _angle, _rotate, _size, _col);
  }
  
   public void drawMe(){
    for(int i = 0; i < step; i++){
      float s = atari + (size * 2 - atari) / step * i;
      //println(s);
      int c = color(hue(col), saturation(col), brightness(col), alpha(col) / step);
      //println(c);
      noStroke();
      fill(c);
      ellipse(pos.x, pos.y, s, s);
    }
    fill(icol);
    stroke(col);
    strokeWeight(3);
    ellipse(pos.x, pos.y, atari, atari);
  }
}

class henyoriDan extends tekiDan{  //敵弾（へにょりレーザー）
  PVector bef = new PVector(0, 0);
  
  henyoriDan(float _x, float _y, float _speed, float _angle, float _size, int _col) {
    super(_x,  _y, _speed, _angle, _size, _col);
  }

  //おーーばーらいど、加速度と角速度つけられるやつ
  henyoriDan(float _x, float _y, float _speed, float _accel, float _angle, float _rotate, float _size, int _col) {
    super(_x, _y, _speed, _accel, _angle, _rotate, _size, _col);
  }
  
   public void drawMe(){
    println("shot rendering");
    fill(col);
    noStroke();
    ellipse(pos.x, pos.y, size, size);
    fill(icol);
    ellipse(pos.x, pos.y, atari, atari);
    if (count_dan != 0)createhenyo();
  }

   public void createhenyo() {
    HenyoriTail henyo =  new HenyoriTail(pos.x, pos.y, bef.x, bef.y, size, col);
    henyo.lifetime = 15;
    Stage s = getStage();
    s.particles.add(henyo);
    bef = pos;
  }
}
//stageクラス
class Stage{
  protected int stageNum;
  List<Enemy> enemys;
  List<Item> items;
  List<Particle> particles;
  Jiki jiki;
  boolean isCounting;
  int scoreRate = 0;
  int count = 0;
  AudioPlayer bgm_Stage;
  AudioPlayer SE_ScoreItem;
  AudioPlayer SE_LifeUP;
  
  Stage(Jiki j){
    jiki = j;
    stageNum = 0;
    enemys = new ArrayList<Enemy>();
    particles = new ArrayList<Particle>();
    items = new ArrayList<Item>();
    isCounting = true;
    //実行中のステージを通知
    stageCode = stageNum;
    SE_ScoreItem = minim.loadFile("魔王魂 効果音 ジッポ-開ける音.mp3");
    SE_LifeUP = minim.loadFile("魔王魂  マジカル15.mp3");
  }
  
   public void updateMe(){
    if(!bgm_Stage.isPlaying()){bgm_Stage.loop();}
    if(isCounting == true){
      count++;
    }
    
    executeBG();
    
    Iterator<Particle> itP = particles.iterator();
    while(itP.hasNext()){
      Particle p = itP.next();
      executeParticle(p);
      if(p.isActive == false){
        println("particle removed");
        itP.remove();
      }
    }
    Iterator<Item> itI = items.iterator();
    while(itI.hasNext()){
      Item i = itI.next();
      executeItem(i);
      if(i.isActive == false){
        switch(i.type){
          case TYPE_ITEM_POINT:
            SE_ScoreItem.play(0);
            totalScore += 10 + scoreRate * ((int)jiki.grazeCount / 10 + 1);
            println(totalScore);
          break;
          case TYPE_ITEM_LIFE:
              if(!SE_LifeUP.isPlaying())SE_LifeUP.play(0);
            if(jiki.HP < 10){
              jiki.HP++;
              println("HPUP");
            }else{
              totalScore += 10000;
            }
          break;
          case TYPE_ITEM_BOMB:
            if(jiki.Bomb < 10){
              jiki.Bomb++;
            }else{
              totalScore += 10000;
            }
          break;
        }
        itI.remove();
      }
    }
    
    executeJiki();
    
    Iterator<Enemy> itE = enemys.iterator();
    while(itE.hasNext()){
      Enemy e = itE.next();
      executeEnemy(e);
      
      //敵が無効化済みかつ、敵機に所属する弾がなくなったら、敵機を削除
      if(e.status == STATUS_ENEMY_DISACTIVE && e.bullets.size() == 0){
        itE.remove();
        //println("enemyRemoved!");
      }
    }
    
    if(enemys.size() == 0 && isCounting == false){
      isCounting = true;
      count++;
    }
    executeUI();
  }
  
  //敵を実行
   public void executeEnemy(Enemy e){
    e.updateMe(jiki);
  }
  
  //自機を実行
   public void executeJiki(){
    jiki.updateMe();
    
    //自機弾を動かす
    Iterator<jikiDan> itS = jiki.shots.iterator();
    while(itS.hasNext()){
      jikiDan s = itS.next();
      judgeEnemysToJikidanCollision(s);
      if(!s.isActive){
        itS.remove();
      }
    }
    
    if(jiki.HP <= 0){
      scene_num = STATUS_GAME_GAMEOVER;
    }
  }
  
   public void executeItem(Item i){
    i.updateMe();
    /* 自機の位置が特定の位置より大きければ自動回収モードにする */
    if(i.suiyoseToJiki(jiki) == true || jiki.pos.y < height / 4){
      i.isAutoKaishu = true;
    }
    if(i.isAutoKaishu == true){
      i.attract(jiki);
    }
    if(i.corrisionToJiki(jiki) == true){
      i.isActive = false;
    }
  }
  
   public void executeParticle(Particle p){
    p.updateMe();
  }
  
  //UIを描画する
   public void executeUI(){
     
    noStroke();
    fill(180, 50, 50, 50);
    rect(0, 0, width / 2 - Play_Haba / 2, height);
    rect(width / 2 + Play_Haba / 2, 0, width, height);
    
    fill(255);
    text("Score:" + totalScore, 0, UI_Height);
    text("Rate:" + scoreRate, 0, UI_Height + mojiSize);
    text("Graze:" + jiki.grazeCount, 0, UI_Height + mojiSize * 2);
    text("LIFE:" + jiki.HP, width / 2 + Play_Haba / 2, UI_Height);
    text("Bomb:" + jiki.Bomb, width / 2 + Play_Haba / 2, UI_Height + mojiSize);
  }
  
  //背景を描画する
   public void executeBG(){
    background(0);
  }
  
   public void endStage(){
    bgm_Stage.pause();
    enemys.clear();
  }
  
  //弾が敵と当たっているか調べる・・・これ重くない？大丈夫？
   public void judgeEnemysToJikidanCollision(jikiDan s){
    Iterator<Enemy> itE = enemys.iterator();
    while(itE.hasNext()){
      Enemy e = itE.next();
      if(s.isHitEnemy(e) && e.status == STATUS_ENEMY_ACTIVE && e.isInvincible == false){
        s.HP--;
        if(!s.isOutOfScreen()){
          for(int i = 0; i < 3; i++){
            popParticle p = new popParticle(s.pos.x, s.pos.y, 5, random(TWO_PI), s.atari, s.col);
            particles.add(p);
          }
        }
        e.HPDown(s.damage);
        scoreRate += e.rate;
      }
    }
  }
  
   public List<Enemy> getEnemyArray(){
    return enemys;
  }
  /* ステージ末尾の敵のステータスが削除済になったらステージ終了 */
}

class stage_1 extends Stage{
  PImage BG;
  stage_1(Jiki j){
    super(j);
    count = 0;
    stageNum = 1;
    bgm_Stage = minim.loadFile("ghost.mp3");
    bgm_Stage.setVolume(50);
    BG = loadImage("patter.png");
  }
  
   public void updateMe(){
    super.updateMe();
    if(count <= 300){
      if(count % 60 == 0){
        enemys.add(new zako_march01(width / 2 + 50, 0));
        enemys.add(new zako_march01(width / 2 + 70, 0));
      }
    }
    if(count > 150 && count <= 150 + 300){
      if(count % 60 == 0){
        enemys.add(new zako_march01(width / 2  - 50, 0));
        enemys.add(new zako_march01(width / 2  - 70, 0));
      }
    }
    if(count > 360 && count <= 360 + 300){
      if(count % 60 == 0){
        enemys.add(new zako_aim01(random(width / 2 - Play_Haba / 2, width / 2 + Play_Haba / 2), 0));
      }
    }
    if(count > 600 && count < 900){
      if(count % 60 == 0){
        enemys.add(new zako_vortex01(random(width / 2 - Play_Haba / 2, width / 2 + Play_Haba / 2), 0));
      }
    }
    if(count > 960 && count < 1200){
      if(count % 60 == 0){
        enemys.add(new zako_uchikaeshi01(random(width / 2 - Play_Haba / 2, width / 2), 0));
        enemys.add(new zako_uchikaeshi01(random(width / 2 + Play_Haba / 2, width / 2), 0));
      }
    }
    if(count == 1260 && isCounting == true){
      isCounting = false;
      enemys.add(new midboss_baramaki(width / 2, 0));
    }
    if(count > 1260 && count < 1260 + 60 * 5){
      if(count % 60 == 0){
        enemys.add(new zako_laser01(random(width / 2 - Play_Haba / 2, width / 2 + Play_Haba / 2), 0));
      }
    }
    if(count > 1760 && count < 1760 + 60 * 5){
      if(count % 60 == 0){
        enemys.add(new zako_allrange02(random(width / 2 - Play_Haba / 2, width / 2 + Play_Haba / 2), 0));
      }
    }
    if(count > 2160 && count < 2400){
      if(count % 60 == 0){
        enemys.add(new zako_allrange01(random(width / 2 - Play_Haba / 2, width / 2 + Play_Haba / 2), 0));
      }
    }
    if(count > 2400 && enemys.size() == 0 && items.size() == 0){
      endStage();
    }
  }
  
   public void executeBG(){
    super.executeBG();
    push();
      tint(100);
      image(BG, 0, frameCount % height);
      image(BG, 0, frameCount % height - height);
    pop();
  }
  
   public void endStage(){
    super.endStage();
    scene_num = STATUS_GAME_CLEAR;
  }
}

class stage1_Boss extends Stage{
  stage1_Boss(Jiki j){
    super(j);
    count = 0;
    stageNum = 2;
  }
}
class Title{
  String weaponName = "none";
  int jikiSelectStatus = 0;
  
  Title(){
    
  }
  
   public void updateMe(){
    drawMe();
  }
  
   public void drawMe(){
    switch(jikiSelectStatus){
      case JIKISELECT_STANDARD:
        weaponName = "standard";
      break;
      case JIKISELECT_RAY:
        weaponName = "ray";
      break;
      case JIKISELECT_HOMING:
        weaponName = "homing";
      break;
      case JIKISELECT_FIRE:
        weaponName = "fire";
      break;
    }
    
    background(0);
    textAlign(CENTER);
    textSize(64);
    text("STGtest", width / 2, height / 2 - 64);
    textSize(32);
    text("Press any key", width / 2, height / 2 - 32);
    text("Weapon", width / 2, height / 2 + 64);
    text(weaponName, width / 2, height / 2 + 96);
  }
  
   public void keyInsert(){
      if(keyCode == LEFT){
        switch(jikiSelectStatus){
          case JIKISELECT_STANDARD:
            jikiSelectStatus = JIKISELECT_RAY;
            break;
          case JIKISELECT_RAY:
            jikiSelectStatus = JIKISELECT_HOMING;
            break;
          case JIKISELECT_HOMING:
            jikiSelectStatus = JIKISELECT_FIRE;
            break;
          case JIKISELECT_FIRE:
            jikiSelectStatus = JIKISELECT_STANDARD;
            break;
        }
      }else if(keyCode == RIGHT){
        switch(jikiSelectStatus){
          case JIKISELECT_STANDARD:
            jikiSelectStatus = JIKISELECT_FIRE;
            break;
          case JIKISELECT_RAY:
            jikiSelectStatus = JIKISELECT_STANDARD;
            break;
          case JIKISELECT_HOMING:
            jikiSelectStatus = JIKISELECT_RAY;
            break;
          case JIKISELECT_FIRE:
            jikiSelectStatus = JIKISELECT_HOMING;
            break;
        }
      }else if(keyCode == 'Z'){
        Jiki jiki = new Jiki();
        switch(jikiSelectStatus){
          case JIKISELECT_STANDARD:
            jiki = new standard();
            break;
          case JIKISELECT_RAY:
            jiki = new lay();
            break;
          case JIKISELECT_HOMING:
            jiki = new homing();
            break;
          case JIKISELECT_FIRE:
            jiki = new fire();
            break;
        }
        stage = new stage_1(jiki);
        textAlign(LEFT);
        textSize(mojiSize);
        scene_num = 1;
    }
  }
}
/* ゲームデータ系 */
final int Play_Haba = 400;
final int UI_Height = 160;

final int PlayFieldLeft = width / 2 - Play_Haba / 2;
final int PlayFieldRight = width / 2 + Play_Haba / 2;

final int mojiSize = 24;  //UI文字サイズ指定

/* ショット形状 */
final int SHOT_ORB = 1;  //丸型
final int SHOT_RICE = 2;  //楕円型
final int SHOT_STAR = 3;  //星形
final int SHOT_HENYO = 4;  //へにょりレーザー風（あとに線パーティクルを残す）

/* 合成方法 */
final int BLEND_ALPHA = 1;  //アルファ（通常）
final int BLEND_ADD = 2;  //加算合成
final int BLEND_SUB = 3;  //減算合成

/* アイテムの種類 */
final int ITEM_SCORE = 1;  //スコアアイテム
final int ITEM_LIFE = 2;  //ライフ回復アイテム

/* 敵の状態 */
final int STATUS_ENEMY_ACTIVE = 0;  //稼働時
final int STATUS_ENEMY_SHOOTDOWN = 1;  //撃ち落された瞬間（finalize実行タイミング/finalize処理内で2に書き換える）
final int STATUS_ENEMY_DISACTIVE = 2;  //撃ち落されてから、自分の弾幕が全部消えるまでの間（削除待ち、敵機はゲームに干渉できない）

/* ゲームの状態 */
final int STATUS_GAME_TITLE = 0;  //タイトル画面
final int STATUS_GAME_PLAYING = 1;  //ゲーム画面
final int STATUS_GAME_GAMEOVER = 2;  //ゲームオーバー画面
final int STATUS_GAME_CLEAR = 3;  //クリア画面

/* 自機の選択 */
final int JIKISELECT_STANDARD = 0;
final int JIKISELECT_RAY = 1;
final int JIKISELECT_HOMING = 2;
final int JIKISELECT_FIRE = 3;

/* アイテムタイプ */
final int TYPE_ITEM_POINT = 0;
final int TYPE_ITEM_LIFE = 1;
final int TYPE_ITEM_BOMB = 2;
 public void corrisionToLaser(Jiki jiki, Laser laser){
  boolean hit = false;
  //条件
  //①：自機の中心からレーザの辺を構成する4つのベクトルへの最短距離を求める。
  //   4つの最短距離のうち一つでもが自機より小さかったら当たっている
  //②?：ただ、最短距離=垂線だとするとレーザーの外側に垂線を降ろしちゃう可能性がある。
  //    なんか角度で判断するのがいいらしいエス
}
//メモ　ショット情報は一元管理ではなく敵機体ごとにする
abstract class Enemy{
  //String state;
  PVector pos;  //位置
  int HP;  //体力
  int size;  //見かけのサイズ
  float atari;  //当たり判定の大きさ
  int col;  //機体の色
  int count_enemy;  //スポーンしてから何F経過したか
  int status;
  int rate = 5;  //倒した際に加算されるスコアレート
  int lifeTime = 0;  //寿命（制限時間） count_enemyがこの値を超えたら削除(撃ち落されモード移行)
  boolean isInvincible;  //無敵かどうか
  List<tekiDan> bullets = new ArrayList<tekiDan>();
  List<Item> dropItem = new ArrayList<Item>();
  
  AudioPlayer SE_Gekitsui;
  AudioPlayer SE_Hit;
  
  Enemy(float _x, float _y){
    pos = new PVector(_x, _y);
    status = STATUS_ENEMY_ACTIVE;
    count_enemy = 0;
    col = color(0, 100, 100);
    size = 15;
    HP = 20;
    atari = size;
    isInvincible = false;
    for(int i = 0; i < 3; i++){
      dropItem.add(new Item(0, 0, TYPE_ITEM_POINT));
    }
    SE_Gekitsui = minim.loadFile("魔王魂  戦闘18.mp3");
    SE_Hit = minim.loadFile("魔王魂  戦闘07.mp3");
  }
  
   public void drawMe(){
    //ボスはisActive = false のときも描画が続くようにして、HP0時の処理で次弾幕開始の位置まで移動する
    if(status == STATUS_ENEMY_ACTIVE){
      fill(col);
      noStroke();
      triangle(pos.x + cos(radians(90)) * size, pos.y + sin(radians(90)) * size,
      pos.x + cos(radians(210)) * size, pos.y + sin(radians(210)) * size,
      pos.x + cos(radians(330)) * size, pos.y + sin(radians(330)) * size);
    }
  }
  
   public void updateMe(Jiki jiki){
    if(status == STATUS_ENEMY_ACTIVE){
      enemy_Move();
      enemy_Shot(jiki);
      if(isOutOfScreen() == true){
        status = STATUS_ENEMY_DISACTIVE;
      }
      if(lifeTime > 0 && count_enemy > lifeTime){  //寿命を過ぎたら死
        status = STATUS_ENEMY_SHOOTDOWN;
      }
    }else if(status == STATUS_ENEMY_SHOOTDOWN){
      shootdown();
    }

    updateBullets(jiki);
    drawMe();
    count_enemy++;
  }
  
   public abstract void enemy_Move();
  
   public abstract void enemy_Shot(Jiki jiki);
  
   public void updateBullets(Jiki jiki){
    
    Iterator<tekiDan> it = bullets.iterator();
    while(it.hasNext()){
      tekiDan d = it.next();
      d.updateMe();
      if(jiki.isInvincible() == false){
        if(d.isGrazeJiki(jiki) && d.isGrazed == false){
          println("graze!");
          jiki.executeGraze(d);
          d.isGrazed = true;
        }
        if(d.isHitJiki(jiki) && d.isActive == true){
          println("hit!");
          jiki.HPDown();
          Stage s = getStage();
          expandCircle p = new expandCircle(d.pos.x, d.pos.y, d.size * 4, d.col);
          s.particles.add(p);
          d.isActive = false;
        }
      }
      if(d.isActive == false){
        it.remove();
      }
    }
  }
  
  //撃ち落された時の挙動
   public void shootdown(){
    SE_Gekitsui.play();
    Stage s = getStage();
    expandCircle p = new expandCircle(pos.x, pos.y, size * 4, color(360, 50));
    s.particles.add(p);
    for(Item i: dropItem){
      i.pos = new PVector(pos.x + random(-size * 2, size * 2), pos.y + random(-size * 2, size * 2));
      s.items.add(i);
    }
    status = STATUS_ENEMY_DISACTIVE;
  }
  
   public void HPDown(int damage){
    HP -= damage;
    if(!SE_Hit.isPlaying())SE_Hit.play(0);
    if(HP <= 0){
     /* ここに撃破エフェクト処理？ */
        status = STATUS_ENEMY_SHOOTDOWN;
    }
  }
  
   public void killAllShot(){
    Iterator<tekiDan> it = bullets.iterator();
    while(it.hasNext()){
      tekiDan d = it.next();
      d.isActive = false;
    }
  }
  
   public boolean isOutOfScreen(){
    //画面外から出てくる奴がいるわけだから、画面範囲は広めに持ったほうがいいのかも？
    if(pos.x > width + size || pos.x < -size || pos.y > height + size || pos.y < -size){
      return true;
    }
    return false;
  }
  
   public List getDropItems(){
    for(Item i: dropItem){
      i.pos = new PVector(pos.x + random(-size * 2, size * 2), pos.y + random(-size * 2, size * 2));
    }
    return dropItem;
  }
}
//ダミー雑魚(ランダム10way円弾)　これをコピペして敵情報をつくってね
class zako_dummy extends Enemy{
  zako_dummy(float _x, float _y){
    super(_x, _y);
  }
  
   public void drawMe(){
    super.drawMe();
  }
  
   public void updateMe(Jiki jiki){
    super.updateMe(jiki);
  }
  
   public void enemy_Move(){
      pos.y += 1;
  }
  
   public void enemy_Shot(Jiki jiki){
    if(count_enemy % 60 == 0){
      int kodo = PApplet.parseInt(random(36));
      for(int i = 0; i < 10; i++){
        orbDan d = new orbDan(pos.x, pos.y, 1.5f, radians(kodo), 16, color(60, 100, 100));
        bullets.add(d);
        kodo += 36;
      }
    }
  }
  
}

class zako_march01 extends Enemy{
    zako_march01(float _x, float _y){
    super(_x, _y);
    HP = 5;
  }
  
   public void drawMe(){
    super.drawMe();
  }
  
   public void updateMe(Jiki jiki){
    super.updateMe(jiki);
  }
  
   public void enemy_Move(){
    pos.y += 1.5f;
  }
  
   public void enemy_Shot(Jiki jiki){
  }
}

class zako_aim01 extends Enemy{
  zako_aim01(float _x, float _y){
    super(_x, _y);
  }
  
   public void drawMe(){
    super.drawMe();
  }
  
   public void updateMe(Jiki jiki){
    super.updateMe(jiki);
  }
  
   public void enemy_Move(){
    if(count_enemy < 60){
      pos.y += 1;
    }else if(count_enemy >= 60 && count_enemy < 90){
      /* なんもせん */
    }
    else{
      pos.y -= 1;
    }
  }
  
   public void enemy_Shot(Jiki jiki){
    if(count_enemy >= 60 && count_enemy < 90){
      if(count_enemy % 10 == 0){
        float angle = atan2(jiki.pos.y - this.pos.y, jiki.pos.x - this.pos.x);
        orbDan d1 = new orbDan(pos.x, pos.y, 1.5f, angle - radians(30), 15, color(90, 100, 100));
        orbDan d2 = new orbDan(pos.x, pos.y, 1.5f, angle, 15, color(90, 100, 100));
        orbDan d3 = new orbDan(pos.x, pos.y, 1.5f, angle + radians(30), 15, color(90, 100, 100));
        bullets.add(d1);
        bullets.add(d2);
        bullets.add(d3);
      }
    }
  }
}

class zako_vortex01 extends Enemy{
  float angle = 0;
  
  zako_vortex01(float _x, float _y){
    super(_x, _y);
  }
  
   public void drawMe(){
    super.drawMe();
  }
  
   public void updateMe(Jiki jiki){
    super.updateMe(jiki);
  }
  
   public void enemy_Move(){
    if(count_enemy < 60){
      pos.y += 1;
    }
    if(count_enemy > 90){
      if(pos.x > width / 2){
        pos.x += 1;
      }else{
        pos.x -= 1;
      }
    }
  }
  
   public void enemy_Shot(Jiki jiki){
    if(count_enemy == 60){
      angle = random(0, 360);
    }
    
    if(count_enemy > 60){
      if(count_enemy % 5 == 0){
        riceDan d1 = new riceDan(pos.x, pos.y, 2, angle, 7.5f, color(240, 40, 100));
        riceDan d2 = new riceDan(pos.x, pos.y, 1.75f, angle, 7.5f, color(240, 40, 100));
        riceDan d3 = new riceDan(pos.x, pos.y, 1.5f, angle, 7.5f, color(240, 40, 100));
        bullets.add(d1);
        bullets.add(d2);
        bullets.add(d3);
        
        angle += radians(360 / 16);
      }
    }
  }
}

class zako_uchikaeshi01 extends Enemy{
  float speed = 2.5f;
  PVector def;
  zako_uchikaeshi01(float _x, float _y){
    super(_x, _y);
    def = pos;
    col = color(300, 100, 100);
  }
  
   public void drawMe(){
    super.drawMe();
  }
  
   public void updateMe(Jiki jiki){
    super.updateMe(jiki);
  }
  
   public void enemy_Move(){
    if(count_enemy < 90){
      pos.y += speed;
    }else{
      pos.y += speed;
      if(def.x > width / 2){
        pos.x -= speed;
      }else{
        pos.x += speed;
      }
    }
  }
  
   public void enemy_Shot(Jiki jiki){
  }
  
   public void HPDown(int damage){
    super.HPDown(damage);
    if(count_enemy % 3 == 0){
      float angle = random(0, TWO_PI);
      for(int i = 0; i < 3; i++){
        triDan d = new triDan(pos.x, pos.y, 3, angle, 20, color(300, 100, 100));
        bullets.add(d);
        angle += TWO_PI / 3;
      }
    }
  }
}

class zako_laser01 extends Enemy{
  float angle = 0;
  zako_laser01(float _x, float _y){
    super(_x, _y);
  }
  
   public void drawMe(){
    super.drawMe();
  }
  
   public void updateMe(Jiki jiki){
    super.updateMe(jiki);
  }
  
   public void enemy_Move(){
    if(count_enemy < 60){
      pos.y += 1.5f;
    }
    if(count_enemy > 90){
      if(pos.x > width / 2){
        pos.x += 1.5f;
      }else{
        pos.x -= 1.5f;
      }
    }
  }
  
   public void enemy_Shot(Jiki jiki){
    if(count_enemy == 60){
      angle = random(0, 360);
    }
    if(count_enemy > 60){
      if(count_enemy % 5 == 0){
        Laser l = new Laser(pos.x, pos.y, 2, angle, 10, 100, color(15, 60, 100));
        bullets.add(l);
        angle += radians(360 / 16);
      }
    }
  }
}

class zako_allrange01 extends Enemy{
  int way = 12;
  
  zako_allrange01(float _x, float _y){
    super(_x, _y);
    HP = 30;
  }
  
   public void drawMe(){
    super.drawMe();
  }
  
   public void updateMe(Jiki jiki){
    super.updateMe(jiki);
  }
  
   public void enemy_Move(){
    if(count_enemy < 60){
      pos.y += 1.5f;
    }
    if(count_enemy > 90){
      if(pos.x > width / 2){
        pos.x += 1.5f;
      }else{
        pos.x -= 1.5f;
      }
    }
  }
  
   public void enemy_Shot(Jiki jiki){
    if(count_enemy == 75){
      for(int i = 0; i < way; i++){
        int c = lerpColor(color(0, 70, 70), color(359, 30, 70), 1.0f / way * i);
        float angle = TWO_PI / way * i;
        growDan d = new growDan(pos.x, pos.y, 2.5f, angle, 28, c);
        bullets.add(d);
      }
    }
  }
}

class zako_allrange02 extends Enemy{
  int way = 20;
  
  zako_allrange02(float _x, float _y){
    super(_x, _y);
  }
  
   public void drawMe(){
    super.drawMe();
  }
  
   public void updateMe(Jiki jiki){
    super.updateMe(jiki);
  }
  
   public void enemy_Move(){
    
    if(count_enemy < 60){
      pos.y += 1.5f;
    }
    if(count_enemy > 90){
      pos.y -= 1;
    }
  }
  
   public void enemy_Shot(Jiki jiki){
    if(count_enemy > 60 && count_enemy < 120){
      if(count_enemy % 15 == 0){
        float angle = random(TWO_PI);
        for(int i = 0; i < way; i++){
          angle += TWO_PI / way;
          triDan d = new triDan(pos.x, pos.y, 2.5f, angle, 20, color(170, 100, 100));
          bullets.add(d);
        }
      }
    }
  }
}


/* ここから中ボス系 */
class midboss_baramaki extends Enemy{
  float angle = 0;
  midboss_baramaki(float _x, float _y){
    super(_x, _y);
    this.HP = 500;
    this.size = 30;
    lifeTime = 500;
    dropItem.add(new Item(0, 0, TYPE_ITEM_LIFE));
    isInvincible = true;  //登場時は無敵にする
  }
  
   public void drawMe(){
    super.drawMe();
  }
  
   public void updateMe(Jiki jiki){
    super.updateMe(jiki);
  }
  
   public void enemy_Move(){
    if(count_enemy < 90){
      pos.y += 1.5f;
    }else if(count_enemy == 90){
      isInvincible = false;
    }
  }
  
   public void enemy_Shot(Jiki jiki){
    if(count_enemy > 90){
      if(count_enemy % 10 == 0){
        angle = atan2(jiki.pos.y - this.pos.y, jiki.pos.x - this.pos.x);
        for(int i = 0; i < 6; i++){
          starDan d = new starDan(pos.x, pos.y, 2, angle + radians(random(-60, 60)), 16, color(random(0, 360), 25, 100, 75));
          bullets.add(d);
          angle += radians(60);
        }
      }
      if((HP < 100 || count_enemy > 400) && count_enemy % 16 == 0){
        angle = atan2(jiki.pos.y - this.pos.y, jiki.pos.x - this.pos.x);
        for(int i = 0; i <= 16; i++){
          growDan d = new growDan(pos.x, pos.y, 3, angle, 16, color(0, 100, 100));
          bullets.add(d);
          angle += TWO_PI / 16;
        }
      }
    }
  }
  
   public void shootdown(){
    super.shootdown();
  }
}

/* ここからボス系 */
class boss_01 extends Enemy{
  boss_01(float _x, float _y){
    super(_x, _y);
    size = 36;
  }
  
   public void drawMe(){
    super.drawMe();
  }
  
   public void updateMe(Jiki jiki){
    super.updateMe(jiki);
  }
  
   public void enemy_Move(){
      pos.y += 1;
  }
  
   public void enemy_Shot(Jiki jiki){
    
  }
}
enum PertType{
  normal,
  henyori
}

enum DanState{
  normal,
  homing,  //敵を追尾(つつーか自動照準)する
  fire  //時間経過で小さくなって消える
};

enum JikiState{  //KORAIL空港鉄道
  normal,
  dead  //被弾後無敵時間さんを作るならいるんじゃないかとおもj
}

enum JikiWeapon{
  none,  //普通の直進弾
  homing,  //追尾弾
  splead,  //広がる弾
  penetrate,  //貫通弾・・・なんだけど同じ敵に複数あたっちゃう問題が解決できないので封印中
  fire  //炎弾、近距離高火力
}

enum EnemyType{
  none,
  zako_dummy,
  zako_aim01,
  zako_circle01,
  zako_vortex01,
  midboss_baramaki01,
  zako_uchikaeshi01,
  zako_march01,
  zako_laser01,
  zako_henyo01,
  boss_01,
  bit_01
}

enum ItemType{  //アイテム実装すんの？
  LifePlus,
  BombPlus,
  Point,
  splead,
  homing,
  fire
}

enum DanShape{  //ショット形状・・・そこまで実装してる余裕があるのか
  orb,  //普通に丸
  rice,  //楕円形　短い半径部分がサイズと思う
  tri,  //三角　メタ的にいうと敵と同じ形だから面倒そう
  davidstar,  //星形　三角を2つ重ねれば六芒星はできる思う
  henyori  //へにょりれーざー（仮）　通った後に軌跡をおく特殊処理がいるよね
}
class GameOver{
  GameOver(){
    
  }
  
   public void updateMe(){
    drawMe();
  }
  
   public void drawMe(){
    background(0);
    text("Gameover", 0, UI_Height - mojiSize);
    text("Score:" + totalScore, 0, UI_Height);
  }
  
   public void keyInsert(){
    if(keyCode == 'Z'){
      gameReset();
      scene_num = STATUS_GAME_TITLE;
    }
  }
}
 public PVector createVectorFromLengthAngle(float leng, float angle){
  float vx = leng * cos(angle);
  float vy = leng * sin(angle);
  return new PVector(vx, vy);
}

 public PVector affineRotate(PVector pos, PVector center, float angle){
  pos.sub(center);
  
  float dx = pos.x * cos(angle) + pos.y * sin(angle) + center.x;
  float dy = pos.x * sin(angle) + pos.y * cos(angle) + center.y;
  
  return new PVector(dx, dy);
}

 public void drawStar(float x, float y, float size, float angle){
  pushMatrix();
    translate(x, y);
    rotate(angle);
    beginShape();
      for(int i = 0; i < 5; i++){
        vertex(size * cos(radians(i * (360 / 5))), size * sin(radians(i * (360 / 5))));
        vertex(size / 2 * cos(radians(i * (360 / 5) + (360 / 10))), size / 2 * sin(radians(i * (360 / 5) + (360 / 10))));
      }
    endShape(CLOSE);
  popMatrix();
}


  public void settings() { size(720, 480);
smooth(); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Shooting" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
